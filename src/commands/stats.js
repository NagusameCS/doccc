/**
 * Stats Command
 * 
 * Generate code statistics and badges using linehook
 */

import { generateLinehookStats } from '../integrations/linehook.js';
import { generateStatsBadges, generateStatsChart } from '../generators/svg/stats.js';
import { writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';

/**
 * Generate code statistics
 */
export async function stats(options = {}) {
    const outputDir = options.output || './assets';
    mkdirSync(outputDir, { recursive: true });

    // Parse patterns
    const include = options.include?.split(',').map(p => p.trim()) || ['**/*.js', '**/*.ts', '**/*.py', '**/*.go', '**/*.rs'];
    const exclude = options.exclude?.split(',').map(p => p.trim()) || ['node_modules/**', 'dist/**', '.git/**'];

    // Generate stats using linehook
    const linehookConfig = { include, exclude };
    const stats = await generateLinehookStats(linehookConfig, outputDir);

    const outputFiles = [];

    // Generate output based on format
    switch (options.format) {
        case 'json':
            const jsonPath = join(outputDir, 'stats.json');
            writeFileSync(jsonPath, JSON.stringify(stats, null, 2), 'utf-8');
            outputFiles.push(jsonPath);
            break;

        case 'markdown':
            const mdPath = join(outputDir, 'stats.md');
            writeFileSync(mdPath, generateMarkdownStats(stats), 'utf-8');
            outputFiles.push(mdPath);
            break;

        case 'svg':
            const svgPath = join(outputDir, 'stats.svg');
            const svg = await generateStatsChart(stats, {
                type: 'languages',
                theme: options.theme || 'auto',
            });
            writeFileSync(svgPath, svg, 'utf-8');
            outputFiles.push(svgPath);
            break;

        case 'badge':
        default:
            // Generate individual badges
            const badges = await generateStatsBadges(stats, {
                style: options.style || 'flat',
                theme: options.theme || 'auto',
            });

            for (const [name, content] of Object.entries(badges)) {
                const badgePath = join(outputDir, `${name}.svg`);
                writeFileSync(badgePath, content, 'utf-8');
                outputFiles.push(badgePath);
            }
            break;
    }

    return {
        ...stats,
        outputFiles,
    };
}

/**
 * Generate markdown stats table
 */
function generateMarkdownStats(stats) {
    const lines = [
        '# Code Statistics',
        '',
        '## Overview',
        '',
        `- **Total Files:** ${stats.totalFiles}`,
        `- **Total Lines:** ${stats.totalLines.toLocaleString()}`,
        `- **Code Lines:** ${stats.codeLines.toLocaleString()}`,
        `- **Comment Lines:** ${stats.commentLines.toLocaleString()}`,
        `- **Blank Lines:** ${stats.blankLines.toLocaleString()}`,
        '',
        '## Languages',
        '',
        '| Language | Files | Lines | % |',
        '|----------|-------|-------|---|',
    ];

    const sortedLangs = Object.entries(stats.languages)
        .sort((a, b) => b[1].lines - a[1].lines);

    for (const [lang, data] of sortedLangs) {
        const percent = ((data.lines / stats.totalLines) * 100).toFixed(1);
        lines.push(`| ${lang} | ${data.files} | ${data.lines.toLocaleString()} | ${percent}% |`);
    }

    lines.push('');
    lines.push(`*Generated by doccc + linehook on ${new Date().toISOString().split('T')[0]}*`);

    return lines.join('\n');
}
